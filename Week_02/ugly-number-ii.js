// 和 剑指offer 的丑数 题目一致
/**
 * @param {number} n
 * @return {number}
 */
var nthUglyNumber = function(n) {
    // 丑数就是质因数只包含 2, 3, 5 的正整数。
    // 相当于 2、3、5 的倍数
    // 4 = 2*2   6 = 2*3   8 = 4*2 = 2*2*2  9 = 3*3   10 = 2*5  12 = 4*3 = 2*2*3

    // 枚举出全部的乘积，然后排序
    // 构造一个元素个数为n的小顶堆，结果返回堆顶
    // 其实可以不用堆，直接拿数组模拟也ok，只要保证生成丑数的数组是由小到大递增，并且非重复
    let seen = new Map()
    // 质因数集合
    let factors = [2,3,5]
    // 初始化计算UNums的堆
    let uNums = [1]
    let nums = [1]


    for (let j = 1; j < n; j++) {

        let uglyN = uNums.shift()
        // 采用堆的一个原因，在于生成丑数的过程中，需要去重
        // 那么就要保证生成的数比堆顶大，如果比堆顶小，则不需要入堆
        // 入堆的排序 + 去重
        /* 这里理解错了，写了一个死循环
        let length = uNums.length
        for (let i = 0; i < length; i++) {
            // 当前uNums不包含新生成的丑数，将丑数加入
            if(uNums.indexOf(uglyN * uNums[i]) < 0) {
                uNums.push(uglyN * uNums[i])
            }
        }
        */
        
        for (let i = 0; i < 3; i++) {
            // 循环在堆内加入新生成的丑数，每次生成三个
             if(uNums.indexOf(uglyN * factors[i]) < 0) {
                uNums.push(uglyN * factors[i])
            }
        }
        // 将uNums排序
        uNums.sort((a,b) => a-b)

        // 如果seen中没有该数的记录，那么可以存入最终nums
        if (seen.get(uglyN) !== true) {
            nums.push(uglyN)
            seen.set(uglyN, true)
        }

    }

    return uNums[0]
    
};

// 将堆简化为指针，指针指代因子，每次只选择生成的最小丑数

/**
 * @param {number} n
 * @return {number}
 */
var nthUglyNumber = function(n) {
    // 试试三指针
    if (n <= 0) return -1;
    if (n <= 6) return n

    // 三个指针分别对应三个质因数
    let p2 = 0, p3 = 0, p5 = 0

    let nums = []
    nums[0] = 1

    for (let i = 1; i < n; i++) {
        // 生成丑数
        nums[i] = Math.min(nums[p2]*2, Math.min(nums[p3]*3, nums[p5]*5))

        // 如果产生重复值，则指针后移
        // 相当于后移产生当前丑数的指针
        if (nums[p2] * 2 == nums[i]) p2 += 1
        if (nums[p3] * 3 == nums[i]) p3 += 1
        if (nums[p5] * 5 == nums[i]) p5 += 1

    }


    return nums[n-1]
};

/**
 * 说一下我对三指针的理解吧。 和动态规划没有关系。

我们知道，丑数的排列肯定是1,2,3,4,5,6,8,10.... 然后有一个特点是，任意一个丑数都是由小于它的某一个丑数*2，*3或者*5得到的，那么如何得到所有丑数呢？ 现在假设有3个数组，分别是： A：{1*2，2*2，3*2，4*2，5*2，6*2，8*2，10*2......}

B：{1*3，2*3，3*3，4*3，5*3，6*3，8*3，10*3......}

C：{1*5，2*5，3*5，4*5，5*5，6*5，8*5，10*5......}

那么所有丑数的排列，必定就是上面ABC3个数组的合并结果然后去重得到的，那么这不就转换成了

三个有序数组的无重复元素合并

的问题了吗？而这三个数组就刚好是{1,2,3,4,5,6,8,10....}乘以2,3,5得到的。

合并有序数组的一个比较好的方法，就是每个数组都对应一个指针，然后比较这些指针所指的数中哪个最小，就将这个数放到结果数组中，然后该指针向后挪一位。

回到本题，要求丑数ugly数组中的第n项，而目前只知道ugly[0]=1，所以此时三个有序链表分别就只有一个元素：

A ： {1*2......}

B ： {1*3......}

C ：{1*5......}

假设三个数组的指针分别是i,j,k，此时均是指向第一个元素，然后比较A[i]，B[j]和C[k]，得到的最小的数A[i]，就是ugly[1]，此时ugly就变成{1,2}了，对应的ABC数组就分别变成了：

A ： {1*2，2*2......}

B ： {1*3, 2*3......}

C ：{1*5,2*5......}

此时根据合并有序数组的原理，A数组指针i就指向了下一个元素，即'2*2'，而j和k依然分别指向B[0]和C[0]，然后进行下一轮合并，就是A[1]和B[0]和C[0]比较，最小值作为ugly[2].....如此循环n次，就可以得到ugly[n]了。

此外，注意到ABC三个数组实际上就是ugly[]*2，ugly[]*3和ugly[]*5的结果，所以每次只需要比较A[i]=ugly[i]*2，B[j]=ugly[j]*3和C[k]=ugly[k]*5的大小即可。然后谁最小，就把对应的指针往后移动一个，为了去重，如果多个元素都是最小，那么这多个指针都要往后移动一个。
 */